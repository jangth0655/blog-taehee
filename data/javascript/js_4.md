---
title: 스코프(Scope), 호이스팅(Hoisting)
category: js
name: ""
---

# <스코프>

## 1. Scope (범위, 한정 짓는 영역)

- 식별자(변수, 함수, 클래스 명)를 **참조할 수 있는 유효한 범위**  
  → 존재하는 이유? 이름 충돌 방지, 메모리 절약  
  → 선언된 위치에 따라 유효범위가 결정됨.  
  → {...} **코드블럭 안**에서만 유효

  -- <br />

  ```javascript
  //블럭 외부에서는 블럭 내부의 변수를 참조할 수 ❌
  const a = "a"; //전역 변수, 전역 스코프(글로벌 변수, 글로벌 스코프)
  {
    const a = "a"; //지역 변수(로컬변수), 지역 스코프(로컬스코프)
  }
  console.log(a);

  //함수 외부에서는 함수 내부의 변수를 참조 ❌
  function print() {
    const message = "hello world";
    console.log(message);
  }
  console.log(message);

  //함수 외부에서는 함수 내부의 매개변수를 참조 ❌
  function sum(a, b) {
    console.log(a, b);
  }
  console.log(a, b);
  ```

  ***

## 2. 가비지 컬렉터(GC) 🗑

- 자바스크립트 엔진에서 자체적으로 제공해준다. (백그라운드 프로세스)  
  → cpu가 동작함. 빈번히 가비지 컬렉터가 움직이다면 청소하는데 리소스가 그만큼 소요된다.  
  → 즉, **불필요한 메모리를 너무 많이 (재)할당하면 안된다.**
- 메모리를 수동적으로 청소할 필요 없이 사용할 수 있다.
- 변수가 어떠한 **오브젝트를 참조하고 있지 않을 때 오브젝트를 메모리에서 청소**해준다.

-- <br />

```javascript
//글로벌 변수는 앱이 종료될때까지 계속 메모리에 유지됨!
const global = 1;
{
  const local = 1;
  //필요한 곳에서 선언하여 사용하는 것이 좋다.
}
// 블럭이 끝나면 메모리가 자동적으로 정리가된다.
```

---

## 3. 실행 컨텍스트 Execution Context

- **코드의 실행 순서와 스코프를 기억!**, 자바스크립트엔진에는 하나의 싱글 컨텍스트 스택이 있음.
- 어떻게 블럭안에 변수의 데이터가 있는지 없는지 확인하고 없다면, 근접한 부모의 스코프를 찾는지 원리는?
- **렉시컬 환경(Lexical Environtment)** 라는 각 블록의 모든 정보를 가지고 있는 내부 오브젝트를 가지고 있다.
- 따라서 실행순서와 각 블럭의 정보를 한 오브젝트 안에 데이터를 담아두고 있다. → **렉시컬 환경**
- 렉스컬 환경  
  ✓ 환경 레코드 : 현재 블럭의 해당하는 정보를 담고 있다.  
  ✓ 외부 환경 참조 : 상위 블럭에 대한 정보를 담고 있다.

---

## 4. 호이스팅 Hoisting

- 사전적: 끌어올리다.
- **자바스크림트 엔진이 코드를 실행하기 전, 변수, 함수, 클래스의 선언문을 끌어 올리는 것을 말함.**
- 변수의 선언과 초기화를 분리한 후, **선언한 코드만 최상단으로 옮김**

-- <br />

```javascript
// 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해줌.
// 따라서 함수의 선언문은 선언 이전에도 호출이 가능하게 해줌.
print();
function print() {
  console.log("hello");
}

// 변수와 클래스는 선언만 호이스팅이 되고,
// 초기화는 안됨.
console.log(hi); //❌ 초기화 전, 변수에 접근하면 컴파일(빌드) 에러 발생!!
let hi = "hi";
let func1 = function () {}; // ❌

const cat = new Cat(); // ❌
class Cat {}
```

---
