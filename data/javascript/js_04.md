---
title: 스코프(Scope), 실행컨텍스트 ,호이스팅(Hoisting)
category: js
name: ''
---

# <스코프>

## 1. Scope (범위, 한정 짓는 영역)

- 식별자(변수, 함수, 클래스 명)를 **참조할 수 있는 유효한 범위**  
  → **식별자가 선언된 위치**와 **어디에서 접근하는지**에 따 **유효범위가 결정**됨.  
  → 블럭안에 있는 변수는 {...} **코드블럭 안**에서만 유효  
  → 스코프 외부에서는 내부 스코프의 식별자를 참조할 수 없다.
- **스코프가 필요한 이유**  
  → 이름 충돌 방지  
  → 블럭 안의 변수는 블럭이 끝나는 순간 메모리에서 자동으로 제거가 된다. (**메모리절약**)
- 종류  
  → 전역스코프 : 코드 가장 바깥 영역
  → 지역스코프 : 함수 등 코드블럭 내부  
  → 동적스코프 : 함수 호출에 따라 결정되는 스코프  
  → **정적스코프(렉시컬 스코프)** : 함수 선언된 위치에 따라 결정된다.  
  → **자바스크립트는 정적스코프를 따른다. 즉, 함수가 어디에서 정의, 선언 했는지에 따라 결정된다.**

- 코드블럭  
  ✓ {}, if(){}, for(){}, function(){} 등등

  ```javascript
  //블럭 외부에서는 블럭 내부의 변수를 참조할 수 ❌
  const a = 'a'; //전역 변수, 전역 스코프(글로벌 변수, 글로벌 스코프)
  {
    const a = 'a'; //지역 변수(로컬변수), 지역 스코프(로컬스코프)
  }
  console.log(a);

  //함수 외부에서는 함수 내부의 변수를 참조 ❌
  function print() {
    const message = 'hello world';
    console.log(message);
  }
  console.log(message);

  //함수 외부에서는 함수 내부의 매개변수를 참조 ❌
  function sum(a, b) {
    console.log(a, b);
  }
  console.log(a, b);
  ```

  ***

## 2. 가비지 컬렉터(GC) 🗑

- 자바스크립트 엔진에서 자체적으로 제공해준다. (백그라운드 프로세스)  
  → cpu가 동작함. 빈번히 **가비지 컬렉터가 움직이다면 청소하는데 리소스가 그만큼 소요**된다.  
  → 즉, **불필요한 메모리를 너무 많이 (재)할당하면 안된다.**
- 메모리를 수동적으로 청소할 필요 없이 사용할 수 있다.
- 변수가 어떠한 **오브젝트를 참조하고 있지 않을 때 오브젝트를 메모리에서 청소**해준다.
- 글로벌 변수는 앱이 종료될때까지 계속 메모리에 유지됨.

```javascript
//글로벌 변수는 앱이 종료될때까지 계속 메모리에 유지됨!
const global = 1;
{
  const local = 1;
  //필요한 곳에서 선언하여 사용하는 것이 좋다.
}
// 블럭이 끝나면 메모리가 자동적으로 정리가된다.
```

---

## 3. 실행 컨텍스트 Execution Context

- 의미 : **코드가 실행되고 있는 구역, 범위**
- **코드의 실행 순서와 스코프를 기억!**, 자바스크립트엔진에는 하나의 싱글 컨텍스트 스택이 있음.
- **렉시컬 환경(Lexical Environment)** 라는 각 블록의 모든 정보를 가지고 있는 내부 오브젝트를 가지고 있다.
- 따라서 실행순서와 각 블럭의 정보를 한 오브젝트 안에 데이터를 담아두고 있다. → **렉시컬 환경**
- **렉시컬 환경 구분**  
  ✓ 환경 레코드 : 현재 블럭의 해당하는 정보를 담고 있다.  
  ✓ 외부 환경 참조 : 상위 블럭에 대한 정보를 담고 있다.
- 어떻게 블럭안에 변수의 데이터가 있는지 없는지 확인하고 없다면, 근접한 부모의 스코프를 찾는지 원리는?  
  → 자바스크립트엔진은 실행하기 전 소스코드를 2개의 과정으로 나눠 진행한다.
  ```text
  1. 소스코드 평가
    > 실행컨텍스트 생성과 렉시컬환경 생성과 실행컨텍스트 스택에 푸시된다.
      * 스택의 가장 최상단은 현재 실행중인 실행컨텍스트가 된다.
    > 변수, 함수 등 식별자 선언문만 먼저 실행
    > 선언되어 생성된 식별자를 컨텍스트가 관리하는 렉시컬환경(스코프 실체)에 등록
  2. 소스코드의 실행
    > 소스 코드 평가과정이 끝나면 실행된다
    > 렉시컬환경에 등록된 식별자와 지역변수, 매개변수를 확인한다.
    > 참조, 지역변수 값의 할당이 시작되고 할당된 값과 결과 값이 다시 렉시컬환경에 등록된다.
    > 만약 변수(식별자)를 찾지 못한 다면 상위 렉시컬환경(상위 스코프)에서 찾을 때까지 확인 한다.
      * 현재 실행중인 실행컨텍스트의 렉시컬환경 외부환경참조에 상위 렉시컬환경이 저장되어 있기 떄문에
    > 즉, 계층적으로 연결된 스코프 체인을 통해 상위 렉시컬환경의 환경레코드를 탐색한다.
    > 실행이 종료되면 실행컨텍스트 스택에서 팝되어 소멸된다.
  ```
- 실행컨텍스트 스택에서 실행컨텍스트가 팝되어진다고 해도 **해당 렉시컬환경이 소멸되는 것은 아니다**.
- 즉, **렉시컬환경을 참조하고 있다면 소멸되지 않고** 그렇지 않다면 가비지컬렉터에 의해 정리된다.

```javascript
var x = 'xxx';

function foo() {
  var y = 'yyy';

  return function bar() {
    var z = 'zzz';
    console.log(x + y + z);
  };
}
const init = foo();
```

- **전역코드 평가와 실행**  
  → 전역 실행컨텍스트를 생성과 스택에 푸시  
  → 렉시컬환경 생성 : 전역 실행컨텍스트와 바인딩  
  → 선언된 변수와 함수가 실행컨텍스트의 렉시컬환경에 등록된다.  
  → this 바인딩, 전역에서 실행되었기 때문에 this는 전역 객체로 바인딩된다.  
  → 렉시컬환경의 외부환경참조에는 상위 렉시컬환경(스코프)이 없기 때문에 null이 할당  
  → 함수 객체를 생성하고 함수 객체 슬롯에는 현재 실행중인 실행컨텍스트(전역)의 렉시컬 환경 참조값이 저장  
  → 실행 : 값의 할당과 함수 호출
- **foo 함수 평가와 실행**  
  → 함수 실행컨텍스트를 생성하고 스택에 푸시  
  → 렉시컬환경 생성 : 전역 실행컨텍스트와 바인딩  
  → 렉시컬환경에 매개변수를 담은 arguments 객체와 지역변수의 선언을 등록  
  → this 바인딩 : 함수 내부를 가리킨다. but 함수의 호출에 따라 달라질 수 있다.  
  → bar함수 객체를 생성하고 내부 슬롯에 foo함수 렉시컬환경 참조값이 저장된다.  
  → 전역 실행컨텍스트에서 생성된 함수 객체 슬롯에 저장된 참조 값이 외부환경참조에 등록된다.  
  → 실행 : y에 값에 할당이 시작되고 bar함수가 호출되며 일시 정지되며 코드 권한이 bar로 옮겨진다.
- **bar 함수 평가와 실행**  
  → 함수 실행컨텍스트를 생성하고 스택에 푸시  
  → 렉시컬환경 생성 : 전역 실행컨텍스트와 바인딩  
  → 렉시컬환경에 매개변수를 담은 arguments 객체와 지역변수의 선언을 등록  
  → this 바인딩 : 함수 내부를 가리킨다. but 함수의 호출에 따라 달라질 수 있다.  
  → foo함수 실행컨텍스트에서 생성된 함수 객체 슬롯에 저장된 참조 값이 외부환경참조에 등록된다.  
  → 실행 : 스코프체인과 외부환경참조를 통해 z,x,y, console을 탐색하고 할당 및 호출한다.
- **bar 함수 종료**  
  → 스택에서 팝되며 현재 실행중인 실행컨텍스트는 foo함수가 된다.  
  → 하지만 변수 init이 리턴된 bar함수를 참조하고 있기 때문에 bar함수의 렉시컬환경은 유지
- **foo 함수 종료**  
  → bar함수를 리턴하고 종료되며, 현재 실행중인 컨텍스트는 전역컨텍스트가된다.  
  → 하지만 bar함수의 렉시컬환경이 참조하고 있기 때문에 foo함수의 렉시컬환경은 유지
- **전역 코드 종료**  
  → 실행할 코드가 더 이상 없다면 종료되며 실행컨텍스트 스택이 비워진다.

---

## 4. 호이스팅 Hoisting

- 사전적: 끌어올리다.
- **자바스크림트 엔진이 코드를 실행하기 전, 변수, 함수, 클래스의 선언문을 끌어 올리는 것을 말함.**
- 변수의 선언과 초기화를 분리한 후, **선언한 코드만 최상단으로 옮김**  
  → 값을 호이스팅 하는 것이 아니다.

```javascript
// 함수의 호이스팅은 함수의 선언문 전에 호출이 가능하게 해줌.
// 따라서 함수의 선언문은 선언 이전에도 호출이 가능하게 해줌.
print();
function print() {
  console.log('hello');
}

// 변수와 클래스는 선언만 호이스팅이 되고,
// 초기화는 안됨.
console.log(hi); //❌ 초기화 전, 변수에 접근하면 컴파일(빌드) 에러 발생!!
let hi = 'hi';
let func1 = function () {}; // ❌

const cat = new Cat(); // ❌
class Cat {}
```

---

## Var (사용 ❌) : 코드의 가독성과 유지보수성에 좋지 않음

- 호이스팅이된다.
- 변수 선언하는 키워드 없이 선언 & 할당이 가능함.
- 선언인지, 재할당인지 구분하기가 어렵다.
- 중복 선언이 가능하다.
- 블록 레벨 스코프가 안된다. 함수 레벨 스코프만 지원된다.

```javascript
something = '❌';
console.log(something);

// 똑같은 이름으로 다시 선언이 가능함
var poo = '❌';
var poo = '❌';

var apple = '사과';
{
  var apple = 'apple';
}
console.log(apple); // output : apple
```
