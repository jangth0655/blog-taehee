---
title: 프로토타입(Prototype)
category: js
createdAt: 2022-8-3
updatedAt: 2022/12/18
---

## 프로토타입

- 사전적 의미 : 원형, 미리 대력적이 행태를 구현

자바스크립트는 **프로토타입 기반의 객체지향 프로그래밍**이다. 따라서 객체 기반의 프로그래밍 언어라고 할 수 있으며 자바스크립트를 이루는 모든 것이 객체(원시 값 제외)다.

#

### 객체 지향 프로그램밍

실세계의 실체(사물, 개념)을 프로그래밍에 접목시키고 여러 개의 독립적인 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.

#

### 객체

속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조

---

## 상속과 프로토타입

우선 상속에 대하여..

어떤 객체(부모)의 프로퍼티 또는 메서드를 다른 객체(자식)가 상속 받아 그대로 사용할 수 있는 것을 말하며 이로인해 불필요한 코드의 중복을 제거고 재사용성을 높일 수 있다.

#

### 프로토타입 객체 특징

- 자바스크립트는 프로토타입을 기반으로 상속을 구현한다. 따라서 하위 객체는 상위 객체의 프로토타입을 자신의 프로토타입인 것처럼 프로토타입의 속성을 자유롭게 사용할 수 있다.
- **모든 객체는 하나의 프로토타입을 갖고** 있고 객체 내부 슬롯의 [[Prototype]]은 프로토타입을 참조한다.
- **프로토타입은 객체 생성 방식에 따라 프로토타입이 결정**된다.
- **모든 프로토타입은 생성자 함수와 연결**되어 있다.
- 프로토타입의 constructor 프로퍼티와 생성자 함수의 prototype 프러퍼티를 통해 서로 접근할 수 있다.

#

### 프로토타입 접근자 프로퍼티 `__proto__`

- 모든 객체는 `__proto__` 접근자를 통해 자신이 프로토타입을 간접적으로 접근할 수 있다.
- 자체적으로 값을 갖지 않으며 프로퍼티의 값을 읽거나 저장할 때 사용하는 **접근자 프로퍼티**이다.
- `__proto__`은 Object.prototype의 프로퍼티이다.  
  **왜 `__proto__` 접근자 함수를 사용하는가??**  
  → 상위 객체 하위 객체의 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서이다. 왜냐하면 프로토타입의 체인은 단방향 링크드 리스트이므로 상호참조를 하게되면 종점이 존재하지 않고 무한루프에 빠지게 된다.

#

### 함수 객체의 prototype 프로퍼티

함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.
(일반 객체는 소유하지 않는다.)

```javascript
(function () {}.hasOwnProperty('prototype'));

// 일반객체는 소유하지 않는다.
({}.hasOwnProperty('prototype'));
```

prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 즉 생성자 함수를 호출할 수 없는 non-constructor인 화살표함수와 메서드 축약표현은 prototype을 소유하지 않으며 프로토타입도 생성하지 않는다. (생성자 함수가 존재하지 않으니까)

- 프로토타입의 constructor 프로퍼티와 생성자 함수  
  모든 프로토타입은 constructor 프로퍼티를 갖고 있으며 constructor는 자신을 참조하고 있는 생성자 함수를 가리킨다. 이러한 연결은 생성자 함수가 생성(함수 객체)될 떄 이뤄진다.

- 객체 리터럴 표기법으로 생성된 객체의 프로토타입과 생성자 함수  
  객체 리터럴 표기법에 의한 객체 생성은 생성자 함수를 호출하지 않고 객체를 생성한다.

  ```javascript
  // obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
  const obj = {};
  console.log(obj.constructor === Object); // true
  ```

  위 예시를 보면 obj는 객체 리터럴 표기법으로 생성된 객체 즉 생성자 함수에 의해 생성된 객체가 아니다. 하지만 obj.constructor는 Object생성자 함수와 연결되어 있다.

  그럼 constructor 프로퍼티를 갖고 있는 이유는 ??  
  모든 객체는 내부적으로 추상연산 OrdinaryObjectCreate가 호출되는데 호출되면 인자로 프로토타입과 프로퍼티를 받고 프로퍼티는 객체에 추가한다. 그리고 이때 프로토타입은 Object.prototype이다.

  이처럼 obj와 같은 리터럴 객체 역시 OrdinaryObjectCreate를 호출하고 이때 Object.prototype 프로토타입으로 갖는 빈 객체를 생성하고 가상의 생성자 함수를 갖는다. 즉 **리터럴 객체가 생성자 함수를 갖는 이유는 프로토타입 constructor 프로퍼티는 생성자 함수와 연결**되어 있기 때문이다.

#

### 프로토타입의 생성 시점

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 즉 생성자 함수를 호출할 수 있는 함수(constructor)는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 생성된다. 생성자함수가 생성되는 방식은 사용자가 직접 정의하거나 자바스크립트 빌트인 생성자 함수로 구분할 수 있다.

```javascript
console.log(Person.prototye);

function Person(name) {
  this.name = name;
}
```

위 예시는 사용자가 직접 정의한 함수 선언문으로 정의된 Person 생성자함수는 호이스팅되어 최상단으로 올라가게되고 먼저 실행된다. 즉 Person 생성자 함수는 가장 먼저 실행되고 함수 객체가 생성되며 이때 프로토타입도 더불어 생성된다. 그리고 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다.

생성된 프로토타입 역시 객체이기 때문에 프로토타입의 프로토타입을 갖고 있는데 프로토타입의 프로토타입은 Object.prototype이다. 이를 좀 더 이해하기 위해서는 빌트인 생성자 함수와 프로토타입 생성 시점에 대해 알아볼 필요가 있다.

#

https://velog.velcdn.com/images%2Fkatanazero86%2Fpost%2Fa691925f-ebdd-46e6-9646-720a1a0d107b%2F%EA%B7%B8%EB%A6%BC1.png

#

### 빌트인 생성자 함수와 프로토타입 생성 시점

`Object, String, Function, Array, RegExp, Date, Promise` 등 같은 빌트인 생성자 함수도 생성자 함수가 생성 되는 시점에 프로토타입이 생성된다.

포인트는 **빌트인 객체 Object는 전역 객체가 생성되는 시점에 생성**된다. 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 따라서 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재한다.

#

### 프로토타입 체인

- 자바스크립트는 객체의 프로퍼티에 접근하려할 때 접근하려는 객체 프로퍼티를 검색한다.
- 접근하려는 객체의 프로퍼티가 없다면 상위 프로토타입의 프로퍼티를 순차적으로 검색한다.
- 프로토타입의 최상위에 위치하는 객체는 언제나 Object.prototype이다. 따라서 모든 객체는 Object.prototype을 상속받는다. (**Object.prototype은 프로토타입 체인의 종점**)

이러한 매커니즘을 **프로토타입 체인**이라고 한다.

### 프로토타입의 교체

부모 객체의 프로토타입을 동적으로 변경할 수 있다. 즉 **객체간의 상속 관계를 동적으로 변경**할 수 있다.

생성자 함수에 의해 교체

```javascript
const Person = (function () {
  function Person(name) {
    this.name = name;

    Person.prototype = {
      sayHello() {
        console.log('Hello');
      },
    };
  }
  return Person;
})();
```

`Person.prototype`에 객체 리터럴을 할당 즉 생성자함수에 의해 생성된 프로토타입을 객체 리터럴로 교체한 것이다. 따라서 객체리터럴에는 constructor가 없으고 me의 생성자 함수는 Object가 나오게 된다.

### 객체 instanceof 생성자 함수 연산자

생성자 함수의 prototype에 바인딩된 프로토타입이 객체의 프로토타입 체인상 존재하는지 여부를 알려주는 연산자이다.

### Object.create

명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. 즉 첫번째 객체로 프로토타입을 생성(프로토타입 체인에 속하는 객체)하여 직접적으로 상속을 구현한다. 두번째 인자는 생성할 객체의 프로퍼티 키와 디스크립터 객체

```javascript
const obj = Object.create(Object.prototypem, {
  x: { value: 1, writable: true, emutable: true, configurable: true },
});
```

- 정적 프로퍼티/메서드  
  생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드를 말한다.  
  · 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티를 말한다.  
  · 생성자 함수 자체적으로 인스턴스 생성하지 않아도 프로퍼티를 가질 수 있다.  
  · 생성자 함수로 생성된 인스턴스에서는 직접적을 호출 및 참조할 수 없다.  
   (인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티가 아니기 때문에)

---

## 디스크립터

- = 프로토타입 object안에서도 object 상태의 정보를 갖고 있는 디스크립터가 있다.
- = **객체 안에 key들을 수정,삭제,열거 할 수 있는지의 정보를 가지고 있는 디스크립터가 있다**.
- = 오브젝트의 각각의 키,값은 프로퍼티 디스크립터라고 하는 객체로 저장됨.

```javascript
const dog = { name: 'wow', emoji: '🐶' };
Object.keys(dog);
Object.values(dog);
Object.entries(dog); // output : [["name","wow"],["emoji","🐶"]]
'name' in dog; // key 확인
dog.hasOwnProperty('name'); // key 확인
```

---

## 객체 불변성

- 동결 : `Object.freeze` → 추가,삭제,쓰기,속성 재정의 ❌,  
  but freeze된 객체에서 다른 객체를 참조하고 있다면 그 참조하는 객체까지는 freeze 하지않는다.
- 밀봉 : `Object.seal` → 값의 수정 ✅ , 추가 ❌, 삭제 ❌, 속성 재정의 ❌  
  → `javascript const cat = {...dog}`
